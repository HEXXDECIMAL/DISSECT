//! Output formatting and reporting.
//!
//! This module handles formatting analysis results for different output modes:
//! - Human-readable terminal output with colors
//! - JSON output for machine consumption
//! - Summary classification for quick triage
//!
//! # Output Modes
//!
//! - Default: Human-readable with colored output
//! - `--json`: Full JSON report
//! - `--summary`: Quick classification only

use crate::types::{AnalysisReport, Criticality, Finding};
use anyhow::Result;
use colored::Colorize;
use std::collections::HashMap;
use std::sync::OnceLock;

/// Cached regex for stripping ANSI escape codes
#[allow(clippy::expect_used)] // Static regex pattern is hardcoded and valid
fn ansi_strip_regex() -> &'static regex::Regex {
    static RE: OnceLock<regex::Regex> = OnceLock::new();
    RE.get_or_init(|| regex::Regex::new(r"\x1b\[[0-9;]*m").expect("valid regex"))
}


/// Extract directory path from trait ID (everything except the last component)
/// e.g., "exec/command/subprocess/popen" -> "exec/command/subprocess"
/// e.g., "malware/cryptominer/monero/wallet-address" -> "malware/cryptominer/monero"
#[must_use] 
fn get_directory_path(id: &str) -> String {
    let parts: Vec<&str> = id.split('/').collect();
    if parts.len() > 1 {
        parts[..parts.len() - 1].join("/")
    } else {
        id.to_string()
    }
}

/// Aggregated finding for a directory path
#[derive(Clone)]
struct AggregatedFinding {
    /// The directory path (e.g., "exec/command/subprocess")
    directory: String,
    /// The best (highest criticality) finding
    best: Finding,
    /// All trait IDs that matched in this directory
    matched_traits: Vec<String>,
}

/// Aggregate findings by directory path, keeping highest criticality (then highest conf)
/// Returns findings with IDs set to directory paths and trait_refs containing all matched trait IDs
/// Internal findings (from code analyzers) are not aggregated - shown individually
#[must_use] 
pub(crate) fn aggregate_findings_by_directory(findings: &[Finding]) -> Vec<Finding> {
    let mut aggregated: HashMap<String, AggregatedFinding> = HashMap::new();
    let mut internal_findings = Vec::new();

    for finding in findings {
        // Check if this is an internal finding (generated by code, not from YAML traits)
        let is_internal = !finding.evidence.is_empty()
            && finding.evidence.iter().any(|e| {
                // Internal sources (generated by analyzers, not from YAML traits)
                e.source == "codesign_parser"
                    || e.source == "binary_analyzer"
                    || e.source == "strings_extractor"
                    || e.source == "import_mapper"
            });

        // Internal findings bypass aggregation - they're shown individually
        if is_internal {
            internal_findings.push(finding.clone());
            continue;
        }

        let dir_path = get_directory_path(&finding.id);

        match aggregated.get_mut(&dir_path) {
            None => {
                aggregated.insert(
                    dir_path.clone(),
                    AggregatedFinding {
                        directory: dir_path,
                        best: finding.clone(),
                        matched_traits: vec![finding.id.clone()],
                    },
                );
            },
            Some(agg) => {
                // Add this trait ID to the list
                if !agg.matched_traits.contains(&finding.id) {
                    agg.matched_traits.push(finding.id.clone());
                }

                // Keep the one with higher criticality
                // If criticality is same, keep the one with higher confidence
                let should_replace = finding.crit > agg.best.crit
                    || (finding.crit == agg.best.crit && finding.conf > agg.best.conf);

                if should_replace {
                    agg.best = finding.clone();
                }
            },
        }
    }

    // Convert aggregated findings to Finding structs with directory as ID
    let mut result: Vec<Finding> = aggregated
        .into_values()
        .map(|agg| {
            let mut result = agg.best;
            result.id = agg.directory;
            result.trait_refs = agg.matched_traits;
            result
        })
        .collect();

    // Add internal findings (not aggregated) to the result
    result.extend(internal_findings);
    result
}


/// Get risk emoji based on criticality
fn risk_emoji(crit: &Criticality) -> &'static str {
    match crit {
        Criticality::Filtered => "â¬œ",
        Criticality::Inert => "âšª",
        Criticality::Notable => "ðŸ”µ",
        Criticality::Suspicious => "ðŸŸ¡",
        Criticality::Hostile => "ðŸ›‘",
    }
}

/// Get risk level name
/// Split trait ID into namespace and rest, skipping "cap"/"obj" prefixes
/// e.g., "cap/exec/command/subprocess" -> ("exec", "command/subprocess")
/// e.g., "obj/anti-analysis/debugger/detect" -> ("anti-analysis", "debugger/detect")
/// e.g., "intel/discover/process/getuid" -> ("intel", "discover/process/getuid")
fn split_trait_id(id: &str) -> (String, String) {
    let parts: Vec<&str> = id.split('/').collect();

    // Skip "cap" or "obj" prefix if present
    let start_idx = if parts.len() > 1 && (parts[0] == "cap" || parts[0] == "obj") {
        1
    } else {
        0
    };

    if parts.len() > start_idx + 1 {
        (
            parts[start_idx].to_string(),
            parts[start_idx + 1..].join("/"),
        )
    } else if parts.len() > start_idx {
        (parts[start_idx].to_string(), parts[start_idx].to_string())
    } else {
        (id.to_string(), id.to_string())
    }
}

/// Convert namespace to long name, capitalizing if no explicit mapping exists
fn namespace_long_name(ns: &str) -> String {
    let mapped = match ns {
        "c2" => Some("COMMAND & CONTROL"),
        "crypto" => Some("CRYPTOGRAPHY"),
        "exfil" => Some("EXFILTRATION"),
        "exec" => Some("EXECUTION"),
        "fs" => Some("FILESYSTEM"),
        "hw" => Some("HARDWARE"),
        "comm" => Some("COMMUNICATION"),
        "os" => Some("OS"),
        "anti-analysis" => Some("ANTI-ANALYSIS"),
        "anti-static" => Some("STATIC EVASION"),
        "anti-forensics" => Some("ANTI-FORENSICS"),
        "privesc" => Some("PRIVILEGE ESCALATION"),
        "process" => Some("PROCESS"),
        "mem" => Some("MEMORY"),
        "data" => Some("DATA"),
        "impact" => Some("IMPACT"),
        "creds" => Some("CREDENTIALS"),
        "lateral" => Some("LATERAL MOVEMENT"),
        "persist" => Some("PERSISTENCE"),
        "discovery" => Some("DISCOVERY"),
        "exploit" => Some("EXPLOIT"),
        "collect" => Some("COLLECTION"),
        "graphics" => Some("GRAPHICS"),
        "interop" => Some("INTEROPERABILITY"),
        "io" => Some("INPUT/OUTPUT"),
        "time" => Some("TIME"),
        "ui" => Some("USER INTERFACE"),
        "meta" => Some("METADATA"),
        _ => None,
    };

    match mapped {
        Some(name) => name.to_string(),
        None => {
            // Full uppercase and replace hyphens with spaces for unknown namespaces
            ns.replace('-', " ").to_uppercase()
        },
    }
}

/// Format evidence string (minimal, deduplicated)
/// Maximum width for evidence display (truncate if longer)
const EVIDENCE_MAX_WIDTH: usize = 80;

/// Make descriptions more terse by removing redundant explanatory parentheticals
fn terse_description(desc: &str) -> String {
    // Remove common verbose patterns that are redundant given the context
    desc.replace(" (timing attacks or sandbox detection)", "")
        .replace(" (C2 communication pattern)", "")
        .replace(" (comprehensive stealer)", "")
        .replace(" (monolithic multicall binary)", "")
        .replace(" (packer pattern)", "")
        .replace(" (potential stealer)", "")
        .replace(" (potential keylogger)", "")
        .replace(" (hardcoded alphabet + decode table)", "")
        .replace(" reveals directory contents", "")
        .replace(" (opendir + readdir + stat)", "")
        .replace(".DS_Store ", "")
        .replace(" (excluding known legitimate)", "")
        .trim()
        .to_string()
}

fn format_evidence(finding: &Finding) -> String {
    let mut seen = std::collections::HashSet::new();
    let values: Vec<String> = finding
        .evidence
        .iter()
        .filter_map(|e| {
            if seen.insert(e.value.clone()) {
                Some(e.value.clone())
            } else {
                None
            }
        })
        .take(5)
        .collect();

    if values.is_empty() {
        return String::new();
    }

    let joined = values.join(", ");

    // Truncate if too long for display
    if joined.len() > EVIDENCE_MAX_WIDTH {
        let mut end = EVIDENCE_MAX_WIDTH - 3;
        while !joined.is_char_boundary(end) && end > 0 {
            end -= 1;
        }
        format!("{}...", &joined[..end])
    } else {
        joined
    }
}

// =============================================================================
// JSONL (Newline-Delimited JSON) Output for Streaming
// =============================================================================

/// JSONL file entry - emitted for each file as it's analyzed
#[derive(serde::Serialize)]
struct JsonlFileEntry<'a> {
    #[serde(rename = "type")]
    entry_type: &'static str,
    #[serde(flatten)]
    file: &'a crate::types::FileAnalysis,
}

/// JSONL summary entry - emitted at the end of streaming output
#[derive(serde::Serialize)]
struct JsonlSummary {
    #[serde(rename = "type")]
    entry_type: &'static str,
    files_analyzed: u32,
    hostile: u32,
    suspicious: u32,
    notable: u32,
    analysis_duration_ms: u64,
}

/// Format a single file analysis as a JSONL line
pub(crate) fn format_jsonl_line(file: &crate::types::FileAnalysis) -> Result<String> {
    let entry = JsonlFileEntry {
        entry_type: "file",
        file,
    };
    Ok(serde_json::to_string(&entry)?)
}

/// Format the summary as a JSONL line (for end of streaming output)
fn format_jsonl_summary(report: &AnalysisReport) -> Result<String> {
    let summary = report.summary.as_ref();
    let counts = summary.map(|s| &s.counts);

    let entry = JsonlSummary {
        entry_type: "summary",
        files_analyzed: summary.map(|s| s.files_analyzed).unwrap_or(report.files.len() as u32),
        hostile: counts.map(|c| c.hostile).unwrap_or(0),
        suspicious: counts.map(|c| c.suspicious).unwrap_or(0),
        notable: counts.map(|c| c.notable).unwrap_or(0),
        analysis_duration_ms: report.metadata.analysis_duration_ms,
    };
    Ok(serde_json::to_string(&entry)?)
}

/// Format entire report as JSONL (for non-streaming output)
pub(crate) fn format_jsonl(report: &AnalysisReport) -> Result<String> {
    let mut lines = Vec::with_capacity(report.files.len() + 1);

    // Emit each file as a line
    for file in &report.files {
        lines.push(format_jsonl_line(file)?);
    }

    // Emit summary at end
    lines.push(format_jsonl_summary(report)?);

    Ok(lines.join("\n"))
}

/// Parse JSONL (newline-delimited JSON) back to AnalysisReport
pub(crate) fn parse_jsonl(jsonl: &str) -> Result<AnalysisReport> {
    let mut files = Vec::new();
    let mut summary = None;
    let mut schema_version = "2.0".to_string();
    let mut analysis_timestamp = chrono::Utc::now();
    let mut scanned_path = None;
    let mut metadata = crate::types::AnalysisMetadata::default();

    // Parse each line as a JSON entry
    for line in jsonl.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }

        let value: serde_json::Value = serde_json::from_str(trimmed)?;
        let entry_type = value.get("type").and_then(|v| v.as_str());

        match entry_type {
            Some("file") => {
                // Parse as FileAnalysis
                let file: crate::types::FileAnalysis = serde_json::from_value(value)?;
                files.push(file);
            },
            Some("summary") => {
                // Extract summary metadata
                if let Some(sv) = value.get("schema_version").and_then(|v| v.as_str()) {
                    schema_version = sv.to_string();
                }
                if let Some(ts) = value.get("analysis_timestamp") {
                    if let Ok(timestamp) =
                        serde_json::from_value::<chrono::DateTime<chrono::Utc>>(ts.clone())
                    {
                        analysis_timestamp = timestamp;
                    }
                }
                if let Some(sp) = value.get("scanned_path") {
                    scanned_path = sp.as_str().map(std::string::ToString::to_string);
                }
                if let Some(tools) = value.get("tools_used").and_then(|v| v.as_array()) {
                    metadata.tools_used =
                        tools.iter().filter_map(|v| v.as_str().map(std::string::ToString::to_string)).collect();
                }
                if let Some(errors) = value.get("errors").and_then(|v| v.as_array()) {
                    metadata.errors =
                        errors.iter().filter_map(|v| v.as_str().map(std::string::ToString::to_string)).collect();
                }
                if let Some(duration) = value.get("analysis_duration_ms").and_then(serde_json::Value::as_u64) {
                    metadata.analysis_duration_ms = duration;
                }
                summary = Some(crate::types::ReportSummary {
                    files_analyzed: value
                        .get("files_analyzed")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(files.len() as u64) as u32,
                    max_depth: 0,
                    counts: crate::types::FindingCounts {
                        hostile: value.get("hostile").and_then(serde_json::Value::as_u64).unwrap_or(0) as u32,
                        suspicious: value.get("suspicious").and_then(serde_json::Value::as_u64).unwrap_or(0)
                            as u32,
                        notable: value.get("notable").and_then(serde_json::Value::as_u64).unwrap_or(0) as u32,
                    },
                    max_risk: None,
                });
            },
            _ => {
                // Unknown entry type, skip
            },
        }
    }

    // Create a minimal AnalysisReport with the parsed data
    let target = if let Some(first_file) = files.first() {
        crate::types::TargetInfo {
            path: first_file.path.clone(),
            file_type: first_file.file_type.clone(),
            sha256: first_file.sha256.clone(),
            size_bytes: first_file.size,
            architectures: None,
        }
    } else {
        crate::types::TargetInfo {
            path: "unknown".to_string(),
            file_type: "unknown".to_string(),
            sha256: String::new(),
            size_bytes: 0,
            architectures: None,
        }
    };

    let mut report = AnalysisReport::new_with_timestamp(target, analysis_timestamp);
    report.schema_version = schema_version;
    report.scanned_path = scanned_path;
    report.files = files;
    report.summary = summary;
    report.metadata = metadata;

    Ok(report)
}

/// Format analysis report for terminal display (malcontent-style)
/// Uses the v2 flat files array structure.
pub(crate) fn format_terminal(report: &AnalysisReport) -> Result<String> {
    let mut output = String::new();

    // Compile ANSI strip regex once, outside all loops
    let ansi_re = ansi_strip_regex();

    // Iterate over files that have findings
    for file in &report.files {
        // Skip files with no findings
        if file.findings.is_empty() {
            continue;
        }

        // Aggregate findings by directory path
        let aggregated = aggregate_findings_by_directory(&file.findings);

        // Filter: remove criticality=none and confidence<0.5
        let filtered: Vec<Finding> = aggregated
            .into_iter()
            .filter(|f| f.crit != Criticality::Inert && f.conf >= 0.5)
            .collect();

        if filtered.is_empty() {
            continue;
        }

        // Group by namespace and count criticality levels
        let mut by_namespace: HashMap<String, Vec<&Finding>> = HashMap::new();
        let mut ns_max_crit: HashMap<String, Criticality> = HashMap::new();
        let mut hostile_count = 0;
        let mut suspicious_count = 0;
        let mut notable_count = 0;

        for finding in &filtered {
            let (ns, _) = split_trait_id(&finding.id);
            let current_max = ns_max_crit.get(&ns).unwrap_or(&Criticality::Inert);
            if &finding.crit > current_max {
                ns_max_crit.insert(ns.clone(), finding.crit);
            }
            by_namespace.entry(ns).or_default().push(finding);

            // Count by criticality
            match finding.crit {
                Criticality::Hostile => hostile_count += 1,
                Criticality::Suspicious => suspicious_count += 1,
                Criticality::Notable => notable_count += 1,
                _ => {},
            }
        }

        // Build summary for file header
        let mut summary_parts = Vec::new();
        if hostile_count > 0 {
            summary_parts.push(format!("ðŸ›‘ {} hostile", hostile_count));
        }
        if suspicious_count > 0 {
            summary_parts.push(format!("ðŸŸ¡ {} suspicious", suspicious_count));
        }
        if notable_count > 0 {
            summary_parts.push(format!("ðŸ”µ {} notable", notable_count));
        }

        let summary = if !summary_parts.is_empty() {
            format!(" â€¢ {}", summary_parts.join(" â€¢ "))
        } else {
            String::new()
        };

        // File header with summary
        output.push_str(&format!("â”œâ”€ {}{}\n", file.path.bright_white(), summary));
        output.push_str("â”‚\n");

        // Sort namespaces by criticality then name, but always put "meta" last
        let mut namespaces: Vec<String> = by_namespace.keys().cloned().collect();
        let mut has_meta = false;
        namespaces.retain(|ns| {
            if ns == "meta" {
                has_meta = true;
                false
            } else {
                true
            }
        });
        namespaces.sort_by(|a, b| {
            let crit_a = ns_max_crit.get(a).unwrap_or(&Criticality::Inert);
            let crit_b = ns_max_crit.get(b).unwrap_or(&Criticality::Inert);
            crit_b
                .cmp(crit_a)
                .then_with(|| namespace_long_name(a).cmp(&namespace_long_name(b)))
        });
        if has_meta {
            namespaces.push("meta".to_string());
        }

        // Render each namespace
        for ns in &namespaces {
            let Some(findings) = by_namespace.get(ns) else {
                continue;
            };
            output.push_str(&format!("â”‚ â—‡ {}\n", &namespace_long_name(ns)));

            let mut sorted_findings = findings.clone();
            sorted_findings.sort_by(|a, b| b.crit.cmp(&a.crit).then_with(|| a.id.cmp(&b.id)));

            for finding in sorted_findings {
                let emoji = risk_emoji(&finding.crit);
                let evidence = format_evidence(finding);
                let desc = terse_description(&finding.desc);

                // Determine if this is an internal finding (generated by code) or from YAML
                let is_internal = !finding.evidence.is_empty()
                    && finding.evidence.iter().any(|e| {
                        // Internal sources (generated by analyzers, not from YAML traits)
                        e.source == "codesign_parser"
                            || e.source == "binary_analyzer"
                            || e.source == "strings_extractor"
                            || e.source == "import_mapper"
                    });

                // Show full trait ID for internal/generated findings
                // Truncate for YAML-loaded findings (to show just the meaningful suffix)
                let trait_id = if is_internal {
                    finding.id.clone()
                } else {
                    let (_, rest) = split_trait_id(&finding.id);
                    rest
                };

                let content = match finding.crit {
                    Criticality::Hostile => {
                        format!("{} {} â€” {}", emoji, trait_id, desc).bright_red()
                    },
                    Criticality::Suspicious => {
                        format!("{} {} â€” {}", emoji, trait_id, desc).bright_yellow()
                    },
                    _ => format!("{} {} â€” {}", emoji, trait_id, desc).bright_cyan(),
                };

                if evidence.is_empty() {
                    output.push_str(&format!("â”‚   {}\n", content));
                } else {
                    // Strip ANSI codes for accurate length measurement
                    let display_len =
                        ansi_re.replace_all(&format!("{}: {}", content, evidence), "").len();
                    if display_len > 120 {
                        output.push_str(&format!("â”‚   {}\n", content));
                        output.push_str(&format!("â”‚      {}\n", evidence.bright_black()));
                    } else {
                        output.push_str(&format!(
                            "â”‚   {}{} {}\n",
                            content,
                            ":".bright_black(),
                            evidence.bright_black()
                        ));
                    }
                }
            }
            output.push_str("â”‚\n");
        }
        // Consistent blank line after each file
        output.push_str("â”‚\n");
    }

    // If no files had findings, show a simple message
    if output.is_empty() {
        output.push_str(&format!("â”œâ”€ {}\n", report.target.path.bright_white()));
        output.push_str("â”‚  No findings\n");
    }

    Ok(output)
}



#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{AnalysisReport, Evidence, FindingKind, TargetInfo, YaraMatch};
    use chrono::Utc;

    fn create_test_report(findings: Vec<Finding>, yara_matches: Vec<YaraMatch>) -> AnalysisReport {
        let mut report = AnalysisReport {
            schema_version: "2.0".to_string(),
            analysis_timestamp: Utc::now(),
            target: TargetInfo {
                path: "/test/sample.bin".to_string(),
                file_type: "ELF".to_string(),
                size_bytes: 12345,
                sha256: "def456abc".to_string(),
                architectures: Some(vec!["x86_64".to_string()]),
            },
            findings,
            traits: vec![],
            structure: vec![],
            functions: vec![],
            strings: vec![],
            sections: vec![],
            imports: vec![],
            exports: vec![],
            yara_matches,
            syscalls: vec![],
            binary_properties: None,
            code_metrics: None,
            source_code_metrics: None,
            overlay_metrics: None,
            metrics: None,
            paths: vec![],
            directories: vec![],
            env_vars: vec![],
            archive_contents: vec![],
            scanned_path: None,
            files: vec![],
            summary: None,
            metadata: crate::types::AnalysisMetadata {
                analysis_duration_ms: 100,
                tools_used: vec!["test".to_string()],
                errors: vec![],
            },
        };
        // Convert to v2 format to populate files array
        report.convert_to_v2(true);
        report
    }

    #[test]
    fn test_aggregate_findings_empty() {
        let findings: Vec<Finding> = vec![];
        let aggregated = aggregate_findings_by_directory(&findings);
        assert_eq!(aggregated.len(), 0);
    }

    #[test]
    fn test_aggregate_findings_different_directories() {
        let findings = vec![
            Finding {
                kind: FindingKind::Capability,
                trait_refs: vec![],
                id: "exec/shell/bash".to_string(),
                desc: "Execute bash".to_string(),
                conf: 0.9,
                crit: Criticality::Hostile,
                mbc: None,
                attack: None,
                evidence: vec![],
                source_file: None,
            },
            Finding {
                kind: FindingKind::Capability,
                trait_refs: vec![],
                id: "net/http/get".to_string(),
                desc: "HTTP GET request".to_string(),
                conf: 0.8,
                crit: Criticality::Suspicious,
                mbc: None,
                attack: None,
                evidence: vec![],
                source_file: None,
            },
        ];
        let aggregated = aggregate_findings_by_directory(&findings);
        assert_eq!(aggregated.len(), 2);
        // IDs should be directory paths
        let ids: Vec<_> = aggregated.iter().map(|f| f.id.as_str()).collect();
        assert!(ids.contains(&"exec/shell"));
        assert!(ids.contains(&"net/http"));
    }

    #[test]
    fn test_aggregate_findings_same_directory_keeps_highest_criticality() {
        let findings = vec![
            Finding {
                kind: FindingKind::Capability,
                trait_refs: vec![],
                id: "exec/shell/bash".to_string(),
                desc: "Execute bash".to_string(),
                conf: 0.7,
                crit: Criticality::Suspicious,
                mbc: None,
                attack: None,
                evidence: vec![],
                source_file: None,
            },
            Finding {
                kind: FindingKind::Capability,
                trait_refs: vec![],
                id: "exec/shell/sh".to_string(),
                desc: "Execute sh".to_string(),
                conf: 0.7,
                crit: Criticality::Hostile,
                mbc: None,
                attack: None,
                evidence: vec![],
                source_file: None,
            },
        ];
        let aggregated = aggregate_findings_by_directory(&findings);
        assert_eq!(aggregated.len(), 1);
        assert_eq!(aggregated[0].id, "exec/shell");
        assert_eq!(aggregated[0].crit, Criticality::Hostile);
        // Should have both trait IDs in trait_refs
        assert_eq!(aggregated[0].trait_refs.len(), 2);
    }

    #[test]
    fn test_aggregate_findings_same_directory_keeps_highest_confidence() {
        let findings = vec![
            Finding {
                kind: FindingKind::Capability,
                trait_refs: vec![],
                id: "exec/shell/bash".to_string(),
                desc: "Execute bash".to_string(),
                conf: 0.6,
                crit: Criticality::Hostile,
                mbc: None,
                attack: None,
                evidence: vec![],
                source_file: None,
            },
            Finding {
                kind: FindingKind::Capability,
                trait_refs: vec![],
                id: "exec/shell/sh".to_string(),
                desc: "Execute sh".to_string(),
                conf: 0.9,
                crit: Criticality::Hostile,
                mbc: None,
                attack: None,
                evidence: vec![],
                source_file: None,
            },
        ];
        let aggregated = aggregate_findings_by_directory(&findings);
        assert_eq!(aggregated.len(), 1);
        assert_eq!(aggregated[0].id, "exec/shell");
        assert_eq!(aggregated[0].conf, 0.9);
    }


    #[test]
    fn test_risk_emoji() {
        assert_eq!(risk_emoji(&Criticality::Inert), "âšª");
        assert_eq!(risk_emoji(&Criticality::Notable), "ðŸ”µ");
        assert_eq!(risk_emoji(&Criticality::Suspicious), "ðŸŸ¡");
        assert_eq!(risk_emoji(&Criticality::Hostile), "ðŸ›‘");
    }

    #[test]
    fn test_split_trait_id() {
        let (ns, rest) = split_trait_id("intel/discover/process");
        assert_eq!(ns, "intel");
        assert_eq!(rest, "discover/process");
    }

    #[test]
    fn test_split_trait_id_no_namespace() {
        let (ns, rest) = split_trait_id("test");
        assert_eq!(ns, "test");
        assert_eq!(rest, "test");
    }

    #[test]
    fn test_namespace_long_name() {
        assert_eq!(namespace_long_name("c2"), "COMMAND & CONTROL");
        assert_eq!(namespace_long_name("discovery"), "DISCOVERY");
        assert_eq!(namespace_long_name("crypto"), "CRYPTOGRAPHY");
        assert_eq!(namespace_long_name("creds"), "CREDENTIALS");
        assert_eq!(namespace_long_name("anti-static"), "STATIC EVASION");
        assert_eq!(namespace_long_name("comm"), "COMMUNICATION");
        assert_eq!(namespace_long_name("collect"), "COLLECTION");
        assert_eq!(namespace_long_name("impact"), "IMPACT");
        assert_eq!(namespace_long_name("meta"), "METADATA");
        assert_eq!(namespace_long_name("unknown"), "UNKNOWN");
    }

    #[test]
    fn test_format_evidence_empty() {
        let trait_item = Finding {
            kind: FindingKind::Capability,
            trait_refs: vec![],
            id: "test".to_string(),
            desc: "Test trait".to_string(),
            conf: 0.8,
            crit: Criticality::Notable,
            mbc: None,
            attack: None,
            evidence: vec![],
            source_file: None,
        };
        assert_eq!(format_evidence(&trait_item), "");
    }

    #[test]
    fn test_format_evidence_with_values() {
        let trait_item = Finding {
            kind: FindingKind::Capability,
            trait_refs: vec![],
            id: "test".to_string(),
            desc: "Test".to_string(),
            conf: 0.8,
            crit: Criticality::Notable,
            mbc: None,
            attack: None,
            evidence: vec![
                Evidence {
                    method: "yara".to_string(),
                    source: "test".to_string(),
                    value: "cmd.exe".to_string(),
                    location: None,
                },
                Evidence {
                    method: "yara".to_string(),
                    source: "test".to_string(),
                    value: "powershell".to_string(),
                    location: None,
                },
            ],
            source_file: None,
        };
        let formatted = format_evidence(&trait_item);
        assert!(formatted.contains("cmd.exe"));
        assert!(formatted.contains("powershell"));
    }

    #[test]
    fn test_format_terminal_empty_report() {
        let report = create_test_report(vec![], vec![]);
        let output = format_terminal(&report).unwrap();
        assert!(output.contains("/test/sample.bin"));
    }

    #[test]
    fn test_format_terminal_with_capabilities() {
        let capabilities = vec![Finding {
            kind: FindingKind::Capability,
            trait_refs: vec![],
            id: "exec/shell".to_string(),
            desc: "Execute shell commands".to_string(),
            conf: 0.9,
            crit: Criticality::Hostile,
            mbc: None,
            attack: None,
            evidence: vec![],
            source_file: None,
        }];
        let report = create_test_report(capabilities, vec![]);
        let output = format_terminal(&report).unwrap();
        assert!(output.contains("exec/shell") || output.contains("shell"));
    }


}
