    fn detect_capabilities(
        &self,
        node: &tree_sitter::Node,
        source: &[u8],
        report: &mut AnalysisReport,
    ) {
        let mut cursor = node.walk();
        self.walk_ast(&mut cursor, source, report);
    }

    fn walk_ast(
        &self,
        cursor: &mut tree_sitter::TreeCursor,
        source: &[u8],
        report: &mut AnalysisReport,
    ) {
        // Iterative traversal to avoid stack overflow on deeply nested code
        loop {
            let node = cursor.node();

            match node.kind() {
                "call" => {
                    self.analyze_call(&node, source, report);
                    self.analyze_env_var_access(&node, source, report);
                }
                "import_statement" | "import_from_statement" => {
                    self.analyze_import(&node, source, report);
                }
                "assignment" => {
                    self.check_obfuscation(&node, source, report);
                    self.analyze_env_var_access(&node, source, report);
                }
                "subscript" => {
                    // This catches os.environ['VAR'] expressions
                    self.analyze_env_var_access(&node, source, report);
                }
                _ => {}
            }

            if cursor.goto_first_child() {
                continue;
            }
            if cursor.goto_next_sibling() {
                continue;
            }
            loop {
                if !cursor.goto_parent() {
                    return;
                }
                if cursor.goto_next_sibling() {
                    break;
                }
            }
        }
    }

    fn analyze_call(&self, node: &tree_sitter::Node, source: &[u8], report: &mut AnalysisReport) {
        if let Ok(text) = node.utf8_text(source) {
            let capability = if text.contains("eval(") {
                Some((
                    "exec/script/eval",
                    "Evaluates dynamic code",
                    "eval",
                    Criticality::Notable,
                ))
            } else if text.contains("exec(") {
                Some((
                    "exec/script/eval",
                    "Executes dynamic code",
                    "exec",
                    Criticality::Notable,
                ))
            } else if text.contains("compile(") {
                Some((
                    "exec/script/eval",
                    "Compiles dynamic code",
                    "compile",
                    Criticality::Notable,
                ))
            } else if text.contains("__import__(") {
                Some((
                    "anti-analysis/obfuscation/dynamic-import",
                    "Dynamic module import",
                    "__import__",
                    Criticality::Suspicious,
                ))
            } else if text.contains("subprocess.")
                || text.contains("os.system")
                || text.contains("os.popen")
            {
                Some((
                    "exec/command/shell",
                    "Executes system commands",
                    "subprocess/system",
                    Criticality::Notable,
                ))
            } else if text.contains("requests.")
                || text.contains("urllib.")
                || text.contains("http.client")
            {
                Some((
                    "net/http/client",
                    "HTTP client operations",
                    "http_client",
                    Criticality::Notable,
                ))
            } else if text.contains("socket.") {
                Some((
                    "net/socket/create",
                    "Network socket operations",
                    "socket",
                    Criticality::Notable,
                ))
            } else if text.contains("open(") && (text.contains("'w'") || text.contains("\"w\"")) {
                Some((
                    "fs/write",
                    "Write files",
                    "open_write",
                    Criticality::Notable,
                ))
            } else if text.contains("base64.b64decode") {
                Some((
                    "anti-analysis/obfuscation/base64",
                    "Base64 decoding",
                    "b64decode",
                    Criticality::Suspicious,
                ))
            } else {
                None
            };

            if let Some((cap_id, description, pattern, criticality)) = capability {
                if !report.findings.iter().any(|c| c.id == cap_id) {
                    report.findings.push(Finding {
                        kind: FindingKind::Capability,
                        trait_refs: vec![],
                        id: cap_id.to_string(),
                        desc: description.to_string(),
                        conf: 1.0,
                        crit: criticality,
                        mbc: None,
                        attack: None,
                        evidence: vec![Evidence {
                            method: "ast".to_string(),
                            source: "tree-sitter-python".to_string(),
                            value: pattern.to_string(),
                            location: Some(format!("line:{}", node.start_position().row + 1)),
                        }],
                    });
                }
            }
        }
    }

    fn analyze_import(&self, node: &tree_sitter::Node, source: &[u8], report: &mut AnalysisReport) {
        if let Ok(text) = node.utf8_text(source) {
            // Detect suspicious imports
            let suspicious_modules = [
                (
                    "subprocess",
                    "exec/command/shell",
                    "Shell command execution",
                    Criticality::Notable,
                ),
                (
                    "os",
                    "exec/command/shell",
                    "OS operations",
                    Criticality::Notable,
                ),
                (
                    "socket",
                    "net/socket/create",
                    "Network sockets",
                    Criticality::Notable,
                ),
                (
                    "requests",
                    "net/http/client",
                    "HTTP client",
                    Criticality::Notable,
                ),
                (
                    "pickle",
                    "anti-analysis/obfuscation/pickle",
                    "Pickle deserialization",
                    Criticality::Notable,
                ),
                (
                    "ctypes",
                    "exec/dylib/load",
                    "C library loading",
                    Criticality::Notable,
                ),
            ];

            for (module, cap_id, description, criticality) in suspicious_modules {
                if text.contains(module) && !report.findings.iter().any(|c| c.id == cap_id) {
                    report.findings.push(Finding {
                        kind: FindingKind::Capability,
                        trait_refs: vec![],
                        id: cap_id.to_string(),
                        desc: description.to_string(),
                        conf: 0.7, // Import alone is not definitive
                        crit: criticality,
                        mbc: None,
                        attack: None,
                        evidence: vec![Evidence {
                            method: "import".to_string(),
                            source: "tree-sitter-python".to_string(),
                            value: module.to_string(),
                            location: Some(format!("line:{}", node.start_position().row + 1)),
                        }],
                    });
                }
            }
        }
    }

    fn check_obfuscation(
        &self,
        node: &tree_sitter::Node,
        source: &[u8],
        report: &mut AnalysisReport,
    ) {
        if let Ok(text) = node.utf8_text(source) {
            // Detect base64 + eval pattern (common obfuscation)
            if (text.contains("base64") || text.contains("b64decode"))
                && (text.contains("eval") || text.contains("exec"))
                && !report
                    .findings
                    .iter()
                    .any(|c| c.id == "anti-analysis/obfuscation/base64-eval")
            {
                report.findings.push(Finding {
                    kind: FindingKind::Capability,
                    trait_refs: vec![],
                    id: "anti-analysis/obfuscation/base64-eval".to_string(),
                    desc: "Base64 decode followed by eval (obfuscation)".to_string(),
                    conf: 0.95,
                    crit: Criticality::Suspicious,
                    mbc: None,
                    attack: None,
                    evidence: vec![Evidence {
                        method: "pattern".to_string(),
                        source: "tree-sitter-python".to_string(),
                        value: "base64+eval".to_string(),
                        location: Some(format!("line:{}", node.start_position().row + 1)),
                    }],
                });
            }

            // Detect hex string construction
            if text.contains("\\x")
                && text.matches("\\x").count() > 5
                && !report
                    .findings
                    .iter()
                    .any(|c| c.id == "anti-analysis/obfuscation/hex")
            {
                report.findings.push(Finding {
                    kind: FindingKind::Capability,
                    trait_refs: vec![],
                    id: "anti-analysis/obfuscation/hex".to_string(),
                    desc: "Hex-encoded strings".to_string(),
                    conf: 0.9,
                    crit: crate::types::Criticality::Suspicious,
                    mbc: None,
                    attack: None,
                    evidence: vec![Evidence {
                        method: "pattern".to_string(),
                        source: "tree-sitter-python".to_string(),
                        value: "hex_encoding".to_string(),
                        location: Some(format!("line:{}", node.start_position().row + 1)),
                    }],
                });
            }

            // Detect string obfuscation via join
            if text.contains(".join(")
                && (text.contains("chr(") || text.contains("ord("))
                && !report
                    .findings
                    .iter()
                    .any(|c| c.id == "anti-analysis/obfuscation/string-construct")
            {
                report.findings.push(Finding {
                    kind: FindingKind::Capability,
                    trait_refs: vec![],
                    id: "anti-analysis/obfuscation/string-construct".to_string(),
                    desc: "Constructs strings via chr/ord".to_string(),
                    conf: 0.9,
                    crit: crate::types::Criticality::Suspicious,
                    mbc: None,
                    attack: None,
                    evidence: vec![Evidence {
                        method: "pattern".to_string(),
                        source: "tree-sitter-python".to_string(),
                        value: "chr_join_pattern".to_string(),
                        location: Some(format!("line:{}", node.start_position().row + 1)),
                    }],
                });
            }
        }
    }

