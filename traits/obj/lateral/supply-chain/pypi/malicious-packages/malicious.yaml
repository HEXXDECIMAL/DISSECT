# PyPI Malicious Package Patterns (Supply-Chain Specific)
# ATT&CK: T1195.002 (Supply Chain Compromise)
# These patterns are specific to PyPI supply-chain attacks
# Generic behaviors (reverse shells, obfuscation) should be in their objective directories

defaults:
  for: [python]
  attack: "T1195.002"

traits:
  # NOTE: YARA kept for setup-abuse - requires setup.py context plus
  # malicious execution/download/payload-decode combinations
  - id: setup-abuse
    desc: Malicious setup.py execution
    crit: suspicious
    conf: 0.85
    # Limit size to exclude large legitimate libraries
    size_max: 50000
    if:
      type: yara
      source: |
        rule pypi_setup_abuse {
          strings:
            // setup.py context
            $setup1 = "setup(" ascii
            // Command execution primitives commonly abused in setup.py trojans
            $cmd1 = "os.system(" ascii
            $cmd2 = "subprocess.Popen(" ascii
            $cmd3 = "subprocess.run(" ascii
            $cmd4 = "subprocess.check_output(" ascii
            $cmd5 = "shell=True" ascii
            // Dynamic execution patterns
            $exec1 = "exec(" ascii
            $exec2 = "eval(" ascii
            $exec3 = "__import__(" ascii
            // Network/download activity (Python-native)
            $dl1 = "urlopen(" ascii
            $dl2 = "urlretrieve(" ascii
            $dl3 = "requests.get(" ascii
            $dl4 = "requests.post(" ascii
            // Network/download via cross-language invocation (PowerShell/shell in strings)
            $dl5 = "Invoke-WebRequest" ascii nocase
            $dl6 = "DownloadFile" ascii
            $dl7 = "DownloadString" ascii
            $dl8 = "Start-BitsTransfer" ascii nocase
            // Encoded/compressed payload handling
            $payload1 = "b64decode(" ascii
            $payload2 = "base64.b64decode(" ascii
            $payload3 = "zlib.decompress(" ascii
            $payload4 = "gzip.decompress(" ascii
          condition:
            // Require explicit setup() call to avoid false positives in libraries
            // that only mention setuptools/distutils in comments or for version checks
            $setup1 and (
              (any of ($cmd*) and any of ($dl*)) or
              (any of ($exec*) and any of ($payload*)) or
              (2 of ($cmd*, $exec*) and any of ($payload*, $dl*))
            )
        }

  # NOTE: YARA kept for typosquat-exec - requires count-based logic (2 of suspicious
  # patterns) combined with package name detection
  - id: typosquat-exec
    desc: PyPI typosquatting with code execution
    crit: suspicious
    conf: 0.8
    if:
      type: yara
      source: |
        rule pypi_typosquat_exec {
          strings:
            // Common typosquatted package name variants
            $pkg1 = "reqeusts" ascii nocase
            $pkg2 = "reuqests" ascii nocase
            $pkg3 = "urlib3" ascii nocase
            $pkg4 = "ulrib3" ascii nocase
            $pkg5 = "colroama" ascii nocase
            $pkg6 = "colormaa" ascii nocase
            $pkg7 = "numpi" ascii nocase
            $pkg8 = "numppy" ascii nocase
            // With suspicious behavior
            $sus1 = "subprocess" ascii
            $sus2 = "os.system" ascii
            $sus3 = "exec(" ascii
            $sus4 = "eval(" ascii
            // In packaging/install context
            $ctx1 = "setup(" ascii
            $ctx2 = "install_requires" ascii
            $ctx3 = "name=" ascii
          condition:
            (any of ($pkg*) and 2 of ($sus*) and any of ($ctx*))
        }

  # === Internal Indicators (Inert) ===
  - id: install-network-core
    desc: Network activity triggered by package (YARA core)
    crit: inert
    conf: 0.85
    # Limit size to exclude large legitimate libraries
    size_max: 40000
    if:
      type: yara
      source: |
        rule pypi_install_network {
          strings:
            // Module level indicators
            $init = "__init__" ascii
            $version = "__version__" ascii
            // Network
            $net1 = "requests.get" ascii
            $net2 = "requests.post" ascii
            $net3 = "urllib.request" ascii
            $net4 = "urlopen" ascii
            // Command execution
            $exec1 = "exec(" ascii
            $exec2 = "eval(" ascii
            $exec3 = "subprocess" ascii
          condition:
            ($init or $version) and any of ($net*) and any of ($exec*)
        }

  # Author impersonation pattern with code execution patterns
  - id: author-impersonation
    desc: Impersonates package author with malicious
    crit: suspicious
    conf: 0.8
    if:
      type: yara
      source: |
        rule pypi_author_impersonation {
          strings:
            $author1 = "__author__" ascii
            $email1 = "__email__" ascii
            $exec = "exec(" ascii
            $eval = "eval(" ascii
            $b64 = "b64decode" ascii
            $compile = "compile(" ascii
          condition:
            ($author1 and $email1) and any of ($exec, $eval, $b64, $compile)
        }

  # NOTE: YARA kept for gzip-json-payload - requires combining gzip/json patterns
  # with resource loading and code execution in a specific way
  - id: gzip-json-payload
    desc: Loads code payload from gzipped
    crit: suspicious
    conf: 0.85
    if:
      type: yara
      source: |
        rule pypi_gzip_json_payload {
          strings:
            $gzip_open = "gzip.open" ascii
            $json_loads = "json.loads" ascii
            $resources = "resources" ascii
            $json_gz = ".json.gz" ascii
            $b64decode = "b64decode" ascii
            $exec = "exec(" ascii
            $eval = "eval(" ascii
          condition:
            ($gzip_open and $json_loads and any of ($resources, $json_gz)) and any of ($b64decode, $exec, $eval)
        }

  # Vendored popular library module - file identifies itself as belonging
  # to a well-known Python package via module docstring identifier.
  # Common in typosquatting packages that bundle copies of legitimate code.
  - id: vendored-requests-module
    desc: Vendored requests library module identifier
    crit: suspicious
    conf: 0.8
    attack: "T1036.005"
    if:
      type: string
      regex: "requests\\.packages(?:\\.|\\b)"
    unless:
      - type: raw
        substr: "from .packages.urllib3"
      - type: raw
        substr: "'requests.packages'"
      - type: raw
        substr: "from .compat import chardet"

  # Vendored requests version metadata file - contains __title__ = "requests"
  # which identifies the file as belonging to the requests library.
  # Typosquatting packages bundle copies of popular libraries including
  # their __version__.py to appear legitimate.
  - id: vendored-requests-version
    desc: Vendored requests library version metadata
    crit: notable
    conf: 0.85
    attack: "T1036.005"
    size_max: 2000
    if:
      type: raw
      regex: '__title__\s*=\s*["\x27]requests["\x27]'

  # Vendored requests library full identity metadata - contains both
  # __title__ = "requests" and __author__ = "Kenneth Reitz".
  # When a small file claims full authorship identity of the requests library,
  # it's a stronger supply-chain impersonation signal than just __title__ alone.
  # Common in typosquatting packages that bundle vendored requests metadata.
  - id: vendored-requests-author-identity
    desc: Vendored requests author identity metadata
    crit: notable
    conf: 0.9
    attack: "T1036.005"
    size_max: 2000
    if:
      type: yara
      source: |
        rule vendored_requests_author_identity {
          strings:
            $title = /__title__\s*=\s*["']requests["']/ ascii
            $author = /__author__\s*=\s*["']Kenneth Reitz["']/ ascii
          condition:
            $title and $author
        }

  # Vendored requests library __init__.py docstring - the file contains the
  # distinctive "Requests HTTP Library" docstring header combined with the
  # Kenneth Reitz copyright. This identifies a vendored copy of the requests
  # library's __init__.py, commonly found in typosquatting packages that
  # bundle legitimate library code to appear genuine on PyPI.
  - id: vendored-requests-init-docstring
    desc: Vendored requests library __init__.py docstring
    crit: notable
    conf: 0.85
    attack: "T1036.005"
    if:
      type: yara
      source: |
        rule vendored_requests_init_docstring {
          strings:
            $docstring = "Requests HTTP Library" ascii
            $copyright = "Kenneth Reitz" ascii
            $import_api = "from .api import" ascii
          condition:
            $docstring and $copyright and $import_api
        }

  # Vendored requests __init__.py with dense relative imports â€” the file
  # imports from many submodules (api, models, sessions, exceptions, etc.)
  # that typically don't exist in the typosquatting package, making the
  # module non-functional on import. This is a hallmark of supply-chain
  # packages whose real payload runs during install, not import.
  # Excludes the real requests library by checking for check_compatibility,
  # a function present in the genuine library but absent in typosquats.
  - id: vendored-requests-init-broken
    desc: Vendored requests init with broken imports
    crit: notable
    conf: 0.85
    attack: "T1036.005"
    if:
      type: yara
      source: |
        rule vendored_requests_init_broken {
          strings:
            $docstring = "Requests HTTP Library" ascii
            $imp1 = "from .api import" ascii
            $imp2 = "from .models import" ascii
            $imp3 = "from .sessions import" ascii
            $imp4 = "from .exceptions import" ascii
            $imp5 = "from .status_codes import" ascii
            $real_lib = "check_compatibility" ascii
          condition:
            $docstring and 4 of ($imp*) and not $real_lib
        }

  # Vendored Zope Acquisition module - references Acquisition.Implicit/Explicit
  # and ImplicitAcquisitionWrapper, which are Zope-specific APIs.
  # Found bundled in typosquat packages (e.g., "Acqusition" vs "Acquisition").
  - id: vendored-zope-acquisition
    desc: Vendored Zope Acquisition library module
    crit: suspicious
    conf: 0.8
    attack: "T1036.005"
    if:
      type: string
      regex: "(?:Implicit|Explicit)AcquisitionWrapper"

  # === Telegram Bot Library Dependencies ===
  # Malicious PyPI packages commonly include Telegram bot libraries
  # (pyTelegramBotAPI, Pyrogram, python-telegram-bot) as dependencies
  # to exfiltrate stolen data via Telegram bots.
  - id: telegram-bot-dependency
    desc: Telegram bot library in package dependencies
    crit: suspicious
    conf: 0.85
    if:
      type: string
      regex: "(?:pyTelegramBotAPI|Pyrogram|python-telegram-bot|aiogram|telethon)"

  # NOTE: YARA kept for dependency-injection - requires combining try/except ImportError
  # with pip install patterns in a specific structural way
  # Requires subprocess execution, not just sys.executable reference
  - id: dependency-injection
    desc: Package installs additional dependencies at
    crit: suspicious
    conf: 0.95
    mbc: "B0024"
    if:
      type: yara
      source: |
        rule runtime_dependency_injection {
          strings:
            $except_import = /except\s+ImportError\s*:/
            $subprocess_pip = /subprocess\.(?:call|run|check_call|check_output|Popen)\s*\([^)\n]*(?:['"]pip['"][^)\n]*['"]install['"]|['"][^'"]*pip\s+install[^'"]*['"])/
            $subprocess_m_pip = /subprocess\.(?:call|run|check_call|check_output|Popen)\s*\([^)\n]*['"]-m['"][^)\n]*['"]pip['"][^)\n]*['"]install['"]/
            // Legitimate test code markers
            $pytest = "pytest" ascii
            $test = "def test_" ascii
          condition:
            $except_import and any of ($subprocess_pip, $subprocess_m_pip) and
            not any of ($pytest, $test)
        }

composite_rules:
  # Network activity during install (suspicious)
  - id: install-network
    desc: Network activity triggered by package during installation
    crit: suspicious
    conf: 0.9
    attack: "T1195.002"
    all:
      - id: install-network-core
      - id: obj/lateral/supply-chain/pypi/general::setup-py-file
    unless:
      - type: basename
        exact: "six.py"