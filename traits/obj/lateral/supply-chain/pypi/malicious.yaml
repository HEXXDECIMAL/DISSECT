# PyPI Malicious Package Patterns (Supply-Chain Specific)
# ATT&CK: T1195.002 (Supply Chain Compromise)
# These patterns are specific to PyPI supply-chain attacks
# Generic behaviors (reverse shells, obfuscation) should be in their objective directories

defaults:
  for: [python]
  attack: "T1195.002"

traits:
  # NOTE: YARA kept for setup-abuse - requires combining setup.py context with
  # malicious operations (subprocess + urllib download patterns)
  - id: setup-abuse
    desc: Malicious setup.py execution
    crit: suspicious
    conf: 0.85
    if:
      type: yara
      source: |
        rule pypi_setup_abuse {
          strings:
            // setup.py context
            $setup1 = "setup(" ascii
            $setup2 = "setuptools" ascii
            $setup3 = "distutils" ascii
            // Malicious operations
            $imp1 = "subprocess" ascii
            $imp2 = "os.system" ascii
            $imp3 = "urllib" ascii
            // Download and execute
            $dl1 = "urlopen" ascii
            $dl2 = "urlretrieve" ascii
          condition:
            (any of ($setup*) and any of ($imp*) and any of ($dl*))
        }

  # NOTE: YARA kept for typosquat-exec - requires count-based logic (2 of suspicious
  # patterns) combined with package name detection
  - id: typosquat-exec
    desc: PyPI typosquatting with code execution
    crit: suspicious
    conf: 0.8
    if:
      type: yara
      source: |
        rule pypi_typosquat_exec {
          strings:
            // Common typosquatted package name variants
            $pkg1 = "reqeusts" ascii nocase
            $pkg2 = "reuqests" ascii nocase
            $pkg3 = "urlib3" ascii nocase
            $pkg4 = "ulrib3" ascii nocase
            $pkg5 = "colroama" ascii nocase
            $pkg6 = "colormaa" ascii nocase
            $pkg7 = "numpi" ascii nocase
            $pkg8 = "numppy" ascii nocase
            // With suspicious behavior
            $sus1 = "subprocess" ascii
            $sus2 = "os.system" ascii
            $sus3 = "exec(" ascii
            $sus4 = "eval(" ascii
            // In packaging/install context
            $ctx1 = "setup(" ascii
            $ctx2 = "install_requires" ascii
            $ctx3 = "name=" ascii
          condition:
            (any of ($pkg*) and 2 of ($sus*) and any of ($ctx*))
        }

  # NOTE: YARA kept for install-network - requires combining module-level markers
  # with network activity and exec patterns
  - id: install-network
    desc: Network activity triggered by package
    crit: suspicious
    conf: 0.85
    if:
      type: yara
      source: |
        rule pypi_install_network {
          strings:
            // Module level indicators
            $init = "__init__" ascii
            $version = "__version__" ascii
            // Network
            $net1 = "requests.get" ascii
            $net2 = "requests.post" ascii
            $net3 = "urllib.request" ascii
            $net4 = "urlopen" ascii
            // Command execution
            $exec1 = "exec(" ascii
            $exec2 = "eval(" ascii
            $exec3 = "subprocess" ascii
          condition:
            ($init or $version) and any of ($net*) and any of ($exec*)
        }

  # NOTE: YARA kept for author-impersonation - requires combining author metadata
  # with code execution patterns
  - id: author-impersonation
    desc: Impersonates package author with malicious
    crit: suspicious
    conf: 0.8
    if:
      type: yara
      source: |
        rule pypi_author_impersonation {
          strings:
            $author1 = "__author__" ascii
            $email1 = "__email__" ascii
            $exec = "exec(" ascii
            $eval = "eval(" ascii
            $b64 = "b64decode" ascii
            $compile = "compile(" ascii
          condition:
            ($author1 and $email1) and any of ($exec, $eval, $b64, $compile)
        }

  # NOTE: YARA kept for gzip-json-payload - requires combining gzip/json patterns
  # with resource loading and code execution in a specific way
  - id: gzip-json-payload
    desc: Loads code payload from gzipped
    crit: suspicious
    conf: 0.85
    if:
      type: yara
      source: |
        rule pypi_gzip_json_payload {
          strings:
            $gzip_open = "gzip.open" ascii
            $json_loads = "json.loads" ascii
            $resources = "resources" ascii
            $json_gz = ".json.gz" ascii
            $b64decode = "b64decode" ascii
            $exec = "exec(" ascii
            $eval = "eval(" ascii
          condition:
            ($gzip_open and $json_loads and any of ($resources, $json_gz)) and any of ($b64decode, $exec, $eval)
        }

  # Vendored popular library module - file identifies itself as belonging
  # to a well-known Python package via module docstring identifier.
  # Common in typosquatting packages that bundle copies of legitimate code.
  - id: vendored-requests-module
    desc: Vendored requests library module identifier
    crit: suspicious
    conf: 0.8
    attack: "T1036.005"
    if:
      type: string
      regex: "requests\\.packages(?:\\.|\\b)"

  # Vendored Zope Acquisition module - references Acquisition.Implicit/Explicit
  # and ImplicitAcquisitionWrapper, which are Zope-specific APIs.
  # Found bundled in typosquat packages (e.g., "Acqusition" vs "Acquisition").
  - id: vendored-zope-acquisition
    desc: Vendored Zope Acquisition library module
    crit: suspicious
    conf: 0.8
    attack: "T1036.005"
    if:
      type: string
      regex: "(?:Implicit|Explicit)AcquisitionWrapper"

  # === Telegram Bot Library Dependencies ===
  # Malicious PyPI packages commonly include Telegram bot libraries
  # (pyTelegramBotAPI, Pyrogram, python-telegram-bot) as dependencies
  # to exfiltrate stolen data via Telegram bots.
  - id: telegram-bot-dependency
    desc: Telegram bot library in package dependencies
    crit: suspicious
    conf: 0.85
    if:
      type: string
      regex: "(?:pyTelegramBotAPI|Pyrogram|python-telegram-bot|aiogram|telethon)"

  # NOTE: YARA kept for dependency-injection - requires combining try/except ImportError
  # with pip install patterns in a specific structural way
  # Requires subprocess execution, not just sys.executable reference
  - id: dependency-injection
    desc: Package installs additional dependencies at
    crit: suspicious
    conf: 0.95
    mbc: "B0024"
    if:
      type: yara
      source: |
        rule runtime_dependency_injection {
          strings:
            $try = "try:" ascii
            $except = /except\s*(ImportError)?:/
            $import = /import\s+\w+/ ascii
            $pip_install = "pip install" ascii nocase
            $subprocess = "subprocess" ascii
            // Legitimate test code markers
            $pytest = "pytest" ascii
            $test = "def test_" ascii
          condition:
            $try and $except and $import and $pip_install and $subprocess and
            not any of ($pytest, $test)
        }
