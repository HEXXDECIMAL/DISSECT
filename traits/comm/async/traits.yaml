# Async Event Libraries Detection
# These libraries are commonly used in botnets and malware for high-performance I/O
# Can be benign or malicious depending on context

traits:
  # libev event loop (common in Mirai variants)
  - id: async/libev
    description: libev event loop library usage
    criticality: notable
    confidence: 0.7
    condition:
      type: yara
      source: |
        rule libev_usage {
          strings:
            $ev1 = "ev_loop" ascii
            $ev2 = "ev_io_start" ascii
            $ev3 = "ev_io_stop" ascii
            $ev4 = "ev_timer_start" ascii
            $ev5 = "ev_timer_stop" ascii
            $ev6 = "ev_run" ascii
            $ev7 = "ev_break" ascii
            $ev8 = "EV_READ" ascii
            $ev9 = "EV_WRITE" ascii
            $ev10 = "ev_default_loop" ascii
            $err = "libev: " ascii
          condition:
            3 of them or $err
        }

  # libuv async I/O (Node.js, common in cryptominers)
  - id: async/libuv
    description: libuv async I/O library usage
    criticality: notable
    confidence: 0.7
    condition:
      type: yara
      source: |
        rule libuv_usage {
          strings:
            $uv1 = "uv_loop_init" ascii
            $uv2 = "uv_run" ascii
            $uv3 = "uv_tcp_init" ascii
            $uv4 = "uv_tcp_connect" ascii
            $uv5 = "uv_write" ascii
            $uv6 = "uv_read_start" ascii
            $uv7 = "uv_timer_start" ascii
            $uv8 = "uv_async_send" ascii
            $uv9 = "uv_spawn" ascii
            $uv10 = "uv_default_loop" ascii
          condition:
            3 of them
        }

  # c-ares async DNS (common in botnets)
  - id: async/c-ares
    description: c-ares async DNS resolver library
    criticality: notable
    confidence: 0.7
    condition:
      type: yara
      source: |
        rule cares_usage {
          strings:
            $ares1 = "ares_init" ascii
            $ares2 = "ares_gethostbyname" ascii
            $ares3 = "ares_process" ascii
            $ares4 = "ares_destroy" ascii
            $ares5 = "ares_channel" ascii
            $ares6 = "ares_query" ascii
            $ares7 = "ares_search" ascii
            $ares8 = "ares_process.c" ascii
            $ares9 = "ARES_SUCCESS" ascii
          condition:
            2 of them
        }

  # libevent async I/O
  - id: async/libevent
    description: libevent async I/O library usage
    criticality: notable
    confidence: 0.7
    condition:
      type: yara
      source: |
        rule libevent_usage {
          strings:
            $ev1 = "event_base_new" ascii
            $ev2 = "event_base_dispatch" ascii
            $ev3 = "event_add" ascii
            $ev4 = "event_del" ascii
            $ev5 = "bufferevent_" ascii
            $ev6 = "evbuffer_" ascii
            $ev7 = "evdns_" ascii
            $ev8 = "evhttp_" ascii
          condition:
            3 of them
        }

  # Boost.Asio async I/O
  - id: async/boost-asio
    description: Boost.Asio async I/O library usage
    criticality: notable
    confidence: 0.7
    condition:
      type: yara
      source: |
        rule boost_asio_usage {
          strings:
            $asio1 = "boost::asio" ascii
            $asio2 = "io_service" ascii
            $asio3 = "io_context" ascii
            $asio4 = "async_read" ascii
            $asio5 = "async_write" ascii
            $asio6 = "async_connect" ascii
            $asio7 = "deadline_timer" ascii
          condition:
            $asio1 or 3 of ($asio*)
        }

  # Tokio async runtime (Rust)
  - id: async/tokio
    description: Tokio async runtime (Rust) usage
    criticality: notable
    confidence: 0.7
    condition:
      type: yara
      source: |
        rule tokio_usage {
          strings:
            $tok1 = "tokio::" ascii
            $tok2 = "tokio_runtime" ascii
            $tok3 = "tokio::net" ascii
            $tok4 = "tokio::io" ascii
            $tok5 = "tokio::time" ascii
            $tok6 = "tokio::spawn" ascii
            $cargo = "tokio-" ascii
          condition:
            any of ($tok*) or $cargo
        }

  # High-performance networking with epoll/kqueue
  - id: async/epoll-kqueue
    description: Direct epoll/kqueue usage for async I/O
    criticality: notable
    confidence: 0.65
    condition:
      type: yara
      source: |
        rule epoll_kqueue {
          strings:
            $epoll1 = "epoll_create" ascii
            $epoll2 = "epoll_ctl" ascii
            $epoll3 = "epoll_wait" ascii
            $kqueue1 = "kqueue" ascii
            $kqueue2 = "kevent" ascii
          condition:
            2 of ($epoll*) or ($kqueue1 and $kqueue2)
        }

composite_rules:
  # Botnet-style async networking
  - id: async/botnet-style
    description: High-performance async networking (botnet pattern)
    criticality: suspicious
    confidence: 0.75
    requires_any:
      - type: trait
        id: async/libev
      - type: trait
        id: async/c-ares
      - type: trait
        id: async/libevent
