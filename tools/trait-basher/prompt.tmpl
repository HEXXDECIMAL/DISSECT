{{if .IsBad}}# Known-Bad: Missing Detection{{else}}# Known-Good: False Positive Reduction{{end}}
{{if .IsArchive}}**Source**: {{.ArchiveName}} ({{.Count}} files)
{{range .Files}}- {{.Path}}{{if .Summary}} ({{.Summary}}){{end}}
{{end}}{{else}}**File**: {{.Path}}
{{end}}
**Objective**: {{if .IsBad}}Add high-signal detections for missed behaviors.{{else}}Fix false positives while preserving accurate detections.{{end}}

You are helping us improve DISSECT, a tool designed to detect subtle malware introduced in supply-chain attacks - such as in xzutils or ultralytics, using differential analysis of its capabilities and unique characteristics.

## Constraints
Read `RULES.md`, `TAXONOMY.md`, `PRECISION.md` before editing.

**Critical rules** (from TAXONOMY.md):
- `cap/` cannot reference `obj/` (capabilities are atomic, not intent-inferring)
- `cap/` cannot use `crit: hostile` (hostile requires intent, belongs in `obj/`)
- Trait references are <directory> (any rule within it, recursively) or <directory>::<specific rule id>
- Filenames are NOT part of trait IDs - only directory paths are prefixes
- Tier dependencies: `cap/`→`cap/`+`meta/`, `obj/`→`cap/`+`obj/`+`meta/`, `known/`→all

**Taxonomy** (from TAXONOMY.md):
- `cap/*` = atomic observable capability (inert→notable→suspicious max)
- `obj/*` = composed attacker objective (notable→suspicious→hostile)
- `known/*` = specific malware/tool signature (family-unique only)
- Traits get 3-4 subdirectories under the top-level; each directory should have semantic meaning for ML analysis - no generic directory names allowed.

**Precision** (from PRECISION.md):
- Hostile composites require precision ≥ 4.0 (else downgraded to suspicious)
- Suspicious composites require precision ≥ 2.0 (else downgraded to notable)

**Quality**:
- Use reusable patterns, not sample-specific fingerprints
- Prefer improving existing traits over creating duplicates
- Adjust criticality if behavior is correct but severity wrong
- Build `cap/` first, then compose `obj/` from capabilities
- For source code, consider AST-based treesitter queries as they have the highest precision.
- Pattern-matching precision in descending order: `ast`, `symbol`, `kv`, `string`, `base64`, `xor`, `content`, `hex`
- Tighten queries using techniques like `size_min`, `not`, `near_min', `count_min`', `per_kb_min`, `section`, `near_bytes`, `near_lines`, before using `unless:`/`downgrade:` (see PRECISION.md)
- Validate taxonomy placement (wrong tier = likely broken refactor)
- Adjust criticality if behavior is correct but severity wrong - many traits have an incorrect criticality
- It's OK for a known-good sample to have 1 suspicious trait - sometimes system tool do suspicious things!
- There may be benign files mixed in with the known-bad files - look carefully as some attacks are extremely subtle.
- Hostile criticality is reserved for unquestionably hostile behavior
- Notable criticality is for anything that describes the purpose of a program. If it opens files, runs commands, or makes connections over the internet, that's notable.
- Inert criticality is for traits that almost every program has, or traits that don't help you understand what a program does.
- This tool will be used against millions of samples across the open-source community, be precise accordingly.
- Be very careful to not duplicate traits by searching for them using a keyword or looking for other traits that match the same evidence - prefer improving existing traits rather than creating new ones unless there is a semantic difference.
- New atomic traits should be created in a location as per TAXONOMY.md, not alongside the composite traits that will use them.
- If a behavior would be surprising if included in a random nodejs app that you downloaded - it should be notable or suspicious.

# Success Criteria
- Run dissect --format=jsonl against the file and ensure that it emits no warnings and produces the results you were hoping for. Iterate until it does.
- Ensure that all of the traits that tell the story about what this program does are "notable" rather than "inert"
- Ensure that all traits that would be very surprising from a security point-of-view in a random program are at least "suspicious"
- Ensure that any traits that rely on the same evidence are not duplicates that should be merged.

## Debug Commands
```
{{.DissectBin}} {{.Path}} --format jsonl   # shows full list of traits, including inert
{{.DissectBin}} strings {{.Path}}
{{.DissectBin}} test-rules {{.Path}} --rules "rule-id"
{{.DissectBin}} test-match {{.Path}} --type string --pattern "X"

Reverse-engineering tools like r2 (radare2), nm, readelf are also available.
```

Use `--format jsonl` to see all traits (including inert) for composite building.

**Traits**: {{.TraitsDir}}
