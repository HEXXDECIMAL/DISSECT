{{if .IsBad}}# Known-Bad: Missing Detection{{else}}# Known-Good: False Positive Reduction{{end}}
{{if .IsArchive}}**Source**: {{.ArchiveName}} ({{.Count}} files)
{{range .Files}}- {{.Path}}{{if .Summary}} ({{.Summary}}){{end}}
{{end}}{{else}}**File**: {{.Path}}
{{end}}
**Objective**: {{if .IsBad}}Add high-signal detections for missed behaviors.{{else}}Fix false positives while preserving accurate detections.{{end}}

You are helping us improve DISSECT, a tool designed to detect subtle malware introduced in supply-chain attacks - such as in xzutils or ultralytics, using differential analysis of its capabilities and unique characteristics.

## Constraints
Read `RULES.md`, `TAXONOMY.md`, `PRECISION.md` before editing.

**Critical rules** (from TAXONOMY.md):
- `cap/` cannot reference `obj/` (capabilities are atomic, not intent-inferring)
- `cap/` cannot use `crit: hostile` (hostile requires intent, belongs in `obj/`)
- Trait references are <directory> (any rule within it, recursively) or <directory>::<specific rule id>
- Filenames are NOT part of trait IDs - only directory paths are prefixes
- Tier dependencies: `cap/`→`cap/`+`meta/`, `obj/`→`cap/`+`obj/`+`meta/`, `known/`→all

**Taxonomy** (from TAXONOMY.md):
- `cap/*` = atomic observable capability (inert→notable→suspicious max)
- `obj/*` = composed attacker objective (notable→suspicious→hostile)
- `known/*` = specific malware/tool signature (family-unique only)
- Traits get 3-4 subdirectories under the top-level; each directory should have semantic meaning for ML analysis - no generic directory names allowed.

**Precision** (from PRECISION.md):
- Hostile composites require precision ≥ 4.0 (else downgraded to suspicious)
- Suspicious composites require precision ≥ 2.0 (else downgraded to notable)

**Quality**:
- Use reusable patterns, not sample-specific fingerprints
- Prefer improving existing traits over creating duplicates
- Adjust criticality if behavior is correct but severity wrong
- Build `cap/` first, then compose `obj/` from capabilities
- Pattern-matching precision in descending order: `ast`, `symbol`, `kv`, `string`, `base64`, `xor`, `content`, `hex`
- Tighten queries using techniques like `size_min`, `not`, `near_min', `count_min`', `per_kb_min`, `section`, `near_bytes`, `near_lines`, before using `unless:`/`downgrade:` (see PRECISION.md)
- Validate taxonomy placement (wrong tier = likely broken refactor)
- Adjust criticality if behavior is correct but severity wrong - many traits have an incorrect criticality
- It's OK for a known-good sample to have 1 suspicious trait - sometimes system tool do suspicious things!
- There may be benign files mixed in with the known-bad files - look carefully!
- Hostile criticality is reserved for unquestionably hostile behavior
- Notable criticality is for anything that describes the purpose of a program. If it opens files or makes connections over the internet, that's notable.
- This tool will be used against millions of samples across the open-source community, be precise accordingly.
- No warnings should be emitted when you do your final dissect run against the file - if warnings are shown, fix them.

## Debug Commands
```
{{.DissectBin}} {{.Path}} --format jsonl
{{.DissectBin}} strings {{.Path}}
{{.DissectBin}} test-rules {{.Path}} --rules "rule-id"
{{.DissectBin}} test-match {{.Path}} --type string --pattern "X"

Reverse-engineering tools like r2 (radare2), nm, readelf are also available.
```

Use `--format jsonl` to see all traits (including inert) for composite building.

**Traits**: {{.TraitsDir}}
