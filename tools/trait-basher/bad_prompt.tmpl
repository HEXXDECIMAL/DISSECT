# Known-Bad Sample: Malware Analysis & Detection Engineering

{{if .IsArchive}}**Archive**: {{.ArchiveName}} ({{.Count}} files with concerning findings)
{{range .Files}}- {{.Path}}{{if .Summary}} — {{.Summary}}{{end}}
{{end}}{{else}}**Sample**: {{.Path}}
{{end}}

**Your Role**: Senior malware reverse engineer improving open-source detection capabilities in DISSECT - a tool to detect subtle supply-chain attacks or other kinds of malware through differential analysis.

**Goal**: Analyze this known-malicious sample, create research documentation, and build reusable high-precision traits to detect it and similar malware, or supply-chain attacks that use similar techniques.

---

{{if .ReportExists}}
## Step 1: Review Prior Analysis ✓

Read the existing analysis at `{{.ReportPath}}` to understand the malware, then proceed to Step 2.

{{else}}
## Step 1: Deep Malware Analysis

**Create research report**: `{{.ReportPath}}`

Start with reconnaissance:
```bash
{{.DissectBin}} strings {{.Path}}         # Extract all strings (including encoded)
{{.DissectBin}} --format jsonl {{.Path}}  # Current DISSECT findings
```

Use rizin or Ghidra for deeper analysis of control flow, API calls, and obfuscation.

**Report must cover**:
- Executive summary: What is this malware? What does it do? Threat level?
- Files accessed/leaked with purpose
- Persistence mechanisms (method, location)
- Network command-and-control/exfil (URLs, IPs, protocols, beaconing intervals)
- Hidden/encoded text (strings, decoding methods)
- Structural anomalies (unusual program structure)
- Execution flow (initial execution → final payload)
- Unique characteristics (obfuscation, syscalls, custom protocols, fingerprints)

{{end}}

## Step 2: Gap Analysis

**Create**: `{{.GapAnalysisPath}}`

Compare DISSECT output against your research findings. Document gaps: Does DISSECT detect the C2 pattern? Persistence method? File exfil? Obfuscation? Structural anomalies?

## Step 3: Build Detection Traits

### Create Atomic Capabilities (`micro-behaviors/`)
- Place traits in semantically correct directories per TAXONOMY.md
- Pattern priority: ast > symbol > string > content (highest precision first)
- Max criticality: suspicious
- Search existing traits first to avoid duplicates
- Avoid hardcoding strings that are unlikely to be shared between samples, such as custom C2 IP's or hostnames; focus on detecting techniques.
- Prefer multiple reusable atomic traits over complex regular expressions
- Consider using advanced rule types such as 'metrics' and 'section' to catch obfuscated samples

### Compose Objectives (`objectives/`)
- Combine capabilities to detect attacker intent
- Required precision: hostile ≥4.0, suspicious ≥2.0
- Follow TAXONOMY.md for proper directory placement
- Atomic traits typically live in a seperate more subdirectory away from complex composite traits
- Your goal here is to catch malware that uses similar techniques rather than just this specific sample

## For well-known malware you've heard of before...
- If the malware is particularly infamous, add a rule to known-good/ that would match other similar malware in this family

DO NOT EDIT ANY RUST CODE - ONLY .yaml files

### Validate
```bash
{{.DissectBin}} --format jsonl {{.Path}}                        # Verify traits fire, no YAML warnings or misleading results
{{.DissectBin}} --format jsonl /bin/ls /bin/bash /usr/bin/curl  # Test for false positives and misleading results
```
Note: YAML changes take effect immediately, no rebuild needed.

---

{{if .MayBeBenign}}
**⚠️ Misclassification Check**: If this appears benign after analysis:
```bash
touch {{.BenignMarkerPath}}
```

{{end}}

## Success Criteria

{{if not .ReportExists}}- ✓ Complete research report documenting all malware capabilities
{{end}}- ✓ Gap analysis identifies significant missing detections - for this and similar samples
- ✓ Traits fire on this sample with appropriate criticality
- ✓ Reusable patterns that could potentially work for similar attacks (not sample-specific fingerprints)
- ✓ No duplicate traits (searched existing before creating)
- ✓ Trait IDs reflect semantic organization per TAXONOMY.md (used by humans and ML pipelines)
- ✓ Atomic traits are properly organized based on what they detect rather than living next to intent-based composite rules.
- ✓ Inert traits are accurate and not misleading; inert traits that describe a programs purpose should be upgraded to notable
- ✓ Zero misleading or inaccurate findings (even inert ones)
- ✓ Output accurately describes file capabilities - no false positives.
